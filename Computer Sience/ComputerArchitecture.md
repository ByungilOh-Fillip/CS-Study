# 컴퓨터의 구성

컴퓨터는 하드웨어와 소프트웨어로 나누어진다.
하드웨어는 컴퓨터에서 물리적인 장치를 의미하며 각각 장치별로 역할 구분이 뚜렷하다.
소프트웨어는 하드웨어의 동작을 지시하고 제어하는 명령어 집합이다.

<img src="../img/CS.png"></img>

## 하드웨어의 구성

### 중앙 처리 장치

**주기억장치**에서 프로그램 명령어와 데이터를 읽어와 처리하고 명령어의 수행 순서를 제어함 중앙처리장치는 비교와 연산을 담당하는 **산술논리연산장치(ALU)** 와 명령어의 해석과 실행을 담당하는 **제어장치**, 속도가 빠른 데이터 기억장소인 **레지스터**로 구성되어있다.

### 기억장치
프로그램, 데이터, 연산의 중간 결과를 저장하는 장치

주기억장치와 보조기억장치로 나누어지며, RAM과 ROM도 이곳에 해당한다. 실행중인 프로그램과 같은 프로그램에 필요한 데이터를 일시적으로 저장한다.

보조기억장치는 하드디스크 등을 말하며, 주기억장치에 비해 속도는 느리지만 많은 자료를 영구적으로 보관할 수 있는 장점이 있다.

### 입출력장치
입력과 출력 장치로 나누어짐.

입력 장치는 컴퓨터 내부로 자료를 입력하는 장치 (키보드, 마우스 등)

출력 장치는 컴퓨터에서 외부로 표현하는 장치 (프린터, 모니터, 스피커 등)


## 시스템 버스
하드웨어의 구성요소를 물리적으로 연결
각 구성요소가 다른 구성요소로 데이터를 보낼 수 있도록 통로가 되어줌
용도에 따라 데이터 버스, 주소 버스, 제어 버스로 나누어짐


### 데이터 버스
중앙처리장치와 기타 장치 사이에서 데이터를 전달하는 통로

기억장치와 입출력장치의 명령어와 데이터를 중앙처리장치로 보내거나, 중앙처리장치의 연산 결과를 기억장치와 입출력장치로 보내는 '양방향' 버스

### 주소 버스
데이터를 정확히 실어나르기 위해서는 기억장치 '주소'를 정해주어야 함.
주소버스는 중앙처리장치가 주기억장치나 입출력장치로 **기억장치 주소를 전달하는 통로**이기 때문에 '단방향' 버스임

### 제어 버스
주소 버스와 데이터 버스는 모든 장치에 공유되기 때문에 이를 제어할 수단이 필요함
제어 버스는 중앙처리장치가 기억장치나 입출력장치에 제어 신호를 전달하는 통로임

제어 신호 종류 : 기억장치 읽기 및 쓰기, 버스 요청 및 승인, 인터럽트 요청 및 승인, 클락, 리셋 등
제어 버스는 읽기 동작과 쓰기 동작을 모두 수행하기 때문에 '양방향' 버스임

#### 메모리 관련 제어신호
|제어신호	| 설명 |
|--------|-------|
|Memory Read (MRD) / Read Enable (RE)|	메모리에서 데이터를 읽기 위한 신호 |
|Memory Write (MWR) / Write Enable (WE)	|메모리에 데이터를 쓰기 위한 신호|
|Address Latch Enable (ALE)	|주소를 고정(래치)시키는 신호|
|Bus Request (BR)|	CPU가 데이터버스를 사용하기 위한 요청 신호|
|Bus Grant (BG)	| CPU가 버스 사용을 승인하는 신호|

#### I/O 관련 제어신호
|제어신호	|설명|
|-|-|
|I/O Read (IOR) / Input Enable (IN)|	I/O 장치에서 데이터를 읽는 신호|
|I/O Write (IOW) / Output Enable (OUT)|	I/O 장치에 데이터를 쓰는 신호|
#### 인터럽트 관련 제어신호
|제어신호	|설명|
|-|-|
|Interrupt Request (IRQ)	|외부 장치가 CPU에게 인터럽트를 요청하는 신호|
|Interrupt Acknowledge (IACK)|	CPU가 인터럽트를 수락했다는 신호|
|Non-Maskable Interrupt (NMI)|	무시할 수 없는 긴급 인터럽트 요청|

#### 상태 및 동기화 신호
|제어신호	|설명|
|-|-|
|Clock (CLK)|	CPU와 장치 간 클럭 신호|
|Reset (RST)|	시스템 초기화 신호|
|Ready (RDY)|	장치가 준비 상태인지 확인하는 신호|
|Wait (WAIT)|	CPU가 장치의 응답을 기다릴 때 사용하는 신호|

#### 컴퓨터처리 기본 원리
컴퓨터는 기본적으로 읽고 처리한 뒤 저장하는 과정으로 이루어짐
(READ → PROCESS → WRITE)
이 과정을 진행하면서 끊임없이 주기억장치(RAM)과 소통한다. 이때 운영체제가 64bit라면, CPU는 RAM으로부터 데이터를 한번에 64비트씩 읽어온다.


## CPU(중앙처리 장치) 작동 원리
CPU는 컴퓨터에서 가장 핵심적인 역할을 수행하는 부분. '인간의 두뇌'에 해당
크게 연산장치, 제어장치, 레지스터 3가지로 구성됨

- 연산 장치 - 산술연산과 논리연산 수행 (따라서 산술논리연산장치라고도 불림)

  - 연산에 필요한 데이터를 레지스터에서 가져오고, 연산 결과를 다시 레지스터로 보냄

- 제어 장치 - 명령어를 순서대로 실행할 수 있도록 제어하는 장치

  - 주기억장치에서 프로그램 명령어를 꺼내 해독하고, 그 결과에 따라 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력장치로 보냄 또한 이들 장치가 보낸 신호를 받아, 다음에 수행할 동작을 결정함

- 레지스터 - 고속 기억장치

  - 명령어 주소, 코드, 연산에 필요한 데이터, 연산 결과 등을 임시로 저장

  - 용도에 따라 범용 레지스터와 특수목적 레지스터로 구분됨

  - 중앙처리장치 종류에 따라 사용할 수 있는 레지스터 개수와 크기가 다름

  - 범용 레지스터 : 연산에 필요한 데이터나 연산 결과를 임시로 저장
  - 특수목적 레지스터 : 특별한 용도로 사용하는 레지스터

### 특수 목적 레지스터 중 중요한 것들
- MAR(메모리 주소 레지스터) : 읽기와 쓰기 연산을 수행할 주기억장치 주소 저장
- PC(프로그램 카운터) : 다음에 수행할 명령어 주소 저장
- IR(명령어 레지스터) : 현재 실행 중인 명령어 저장
- MBR(메모리 버퍼 레지스터) : 주기억장치에서 읽어온 데이터 or 저장할 데이터 임시 저장
- AC(누산기) : 연산 결과 임시 저장

### CPU의 동작 과정
1. 주기억장치는 입력장치에서 입력받은 데이터 또는 보조기억장치에 저장된 프로그램 읽어옴
2. CPU는 프로그램을 실행하기 위해 주기억장치에 저장된 프로그램 명령어와 데이터를 읽어와 처리하고 결과를 다시 주기억장치에 저장
3. 주기억장치는 처리 결과를 보조기억장치에 저장하거나 출력장치로 보냄
4. 제어장치는 1~3 과정에서 명령어가 순서대로 실행되도록 각 장치를 제어


#### 명령어 세트란?
CPU가 실행할 명령어의 집합
연산 코드(Operation Code) + 피연산자(Operand)로 이루어짐
연산 코드 : 실행할 연산

피연산자 : 필요한 데이터 or 저장 위치
연산 코드는 연산, 제어, 데이터 전달, 입출력 기능을 가짐
피연산자는 주소, 숫자/문자, 논리 데이터 등을 저장

CPU는 프로그램 실행하기 위해 주기억장치에서 명령어를 순차적으로 인출하여 해독하고 실행하는 과정을 반복함

CPU가 주기억장치에서 한번에 하나의 명령어를 인출하여 실행하는데 필요한 일련의 활동을 '명령어 사이클'이라고 말함

명령어 사이클은 인출/실행/간접/인터럽트 사이클로 나누어짐

주기억장치의 지정된 주소에서 하나의 명령어를 가져오고, 실행 사이클에서는 명령어를 실행함. 하나의 명령어 실행이 완료되면 그 다음 명령어에 대한 인출 사이클 시작

#### 인출 사이클과 실행 사이클에 의한 명령어 처리 과정
인출 사이클에서 가장 중요한 부분은 PC(프로그램 카운터) 값 증가

- PC에 저장된 주소를 MAR로 전달
- 저장된 내용을 토대로 주기억장치의 해당 주소에서 명령어 인출
- 인출한 명령어를 MBR에 저장
- 다음 명령어를 인출하기 위해 PC 값 증가시킴
- 메모리 버퍼 레지스터(MBR)에 저장된 내용을 명령어 레지스터(IR)에 전달

```
T0 : MAR ← PC
T1 : MBR ← M[MAR], PC ← PC+1
T2 : IR ← MBR
```

여기까지는 인출하기까지의 과정

#### 인출한 이후, 명령어를 실행하는 과정

ADD addr 명령어 연산

```
T0 : MAR ← IR(Addr)
T1 : MBR ← M[MAR]
T2 : AC ← AC + MBR
```
이미 인출이 진행되고 명령어만 실행하면 되기 때문에 PC를 증가할 필요x

IR에 MBR의 값이 이미 저장된 상태를 의미함

따라서 AC에 MBR을 더해주기만 하면 됨

## 캐시 메모리 
속도가 빠른 메모리와 느린 메모리 사이의 병목현상을 줄이기 위한 메모리

CPU가 주기억장치에서 저장된 데이터를 읽어올 때, 자주 사용하는 데이터를 캐시 메모리에 저장한 뒤, 다음에 이용할 때 주기억장치가 아닌 캐시 메모리에서 먼저 가져오면서 속도를 향상시킨다.

속도라는 장점을 얻지만, 용량이 적기도 하고 비용이 비싼 점이 있다.


CPU에는 이러한 캐시 메모리가 2~3개 정도 사용된다. (L1, L2, L3 캐시 메모리라고 부른다)

속도와 크기에 따라 분류한 것으로, 일반적으로 L1 캐시부터 먼저 사용된다. (CPU에서 가장 빠르게 접근하고, 여기서 데이터를 찾지 못하면 L2로 감)


듀얼 코어 프로세서의 캐시 메모리 : 각 코어마다 독립된 L1 캐시 메모리를 가지고, 두 코어가 공유하는 L2 캐시 메모리가 내장됨

만약 L1 캐시가 128kb면, 64/64로 나누어 64kb에 명령어를 처리하기 직전의 명령어를 임시 저장하고, 나머지 64kb에는 실행 후 명령어를 임시저장한다. (명령어 세트로 구성, I-Cache - D-Cache)

L1 : CPU 내부에 존재
L2 : CPU와 RAM 사이에 존재
L3 : 보통 메인보드에 존재한다고 함

> 캐싱을 처리하기 위해 사용되는 redis의 경우는 어떤 레벨에서 진행될까?
    Redis는 어디에 해당할까?
    - Redis는 RAM을 활용하는 캐싱 시스템으로 데이터베이스 조회 속도를 높이기 위해 사용됨.
    - CPU 내부 캐시가 아니라, 네트워크를 통해 접근하는 메모리 캐시이므로 속도 차이가 큼.
    - 즉, **Redis는 L1, L2, L3 캐시가 아니라 "애플리케이션 레벨 캐시" 또는 "DB 캐시"** 라고 볼 수 있음


| 캐시 레벨	| 종류	| 속도	| 용도 |
|-|-|-|-|
|L1 캐시|	CPU 내부|	매우 빠름 (나노초)	|CPU 명령어 및 데이터 저장
|L2 캐시|	CPU 내부|	빠름	|L1보다 크지만 약간 느림
|L3 캐시|	CPU 내부 공유|	비교적 빠름	|여러 코어가 공유하는 캐시
|RAM	|DRAM (메인 메모리)|	느림 (마이크로초)	|실행 중인 애플리케이션 데이터 저장
|Redis	|인메모리 DB 캐시	|RAM 속도	|DB 조회 결과, 세션 데이터 저장
|디스크 (SSD/HDD)|	저장장치|	가장 느림 (밀리초)	|장기 데이터 저장

    Redis가 캐싱되는 위치
    Redis는 일반적으로 다음과 같은 캐싱 계층에서 활용:

    DB 캐시: MySQL, MariaDB 같은 DB의 쿼리 결과를 캐싱.

    세션 캐시: 로그인 세션 정보를 저장.

    분산 캐시: 여러 서버에서 공통으로 사용하는 데이터를 빠르게 가져오기 위해 사용.


## 부동 소수점 VS 고정 소수점
### 1.고정 소수점 (Fixed-Point) 변환 과정

예제 1: 6.25를 8비트 고정 소수점으로 변환
소수점이 2자리로 고정된다고 가정하고 변환해보자.

1). 6.25를 2진수로 변환
정수 부분 6을 2진수로 변환

6 ÷ 2 = 3 ... 0  
3 ÷ 2 = 1 ... 1  
1 ÷ 2 = 0 ... 1  
→ (6)₁₀ = (110)₂
소수 부분 0.25를 2진수로 변환

0.25 × 2 = 0.50 → 0  
0.50 × 2 = 1.00 → 1  
→ (0.25)₁₀ = (01)₂
최종 결과:

(6.25)₁₀ = (110.01)₂
2). 고정 소수점 8비트 표현 (소수점 2자리 고정)
만약 8비트로 표현하면, 정수 부분(6비트)과 소수 부분(2비트)을 나누어 저장:

(6.25)₁₀ → (000110.01)₂
결과: 00011001 (8비트)

### 2. 부동 소수점 (Floating-Point) 변환 과정
부동 소수점은 IEEE 754 표준을 따르며, 부호(Sign) + 지수(Exponent) + 가수(Mantissa) 3부분으로 나뉨.

부호 (1비트): 양수면 0, 음수면 1

지수 (8비트): 소수점 이동량을 표현 (127을 더해 저장, Bias 사용)

가수 (23비트): 정규화된 값의 소수점 이하 부분 저장

예제 2: 6.25를 IEEE 754 단정도(32비트) 부동 소수점으로 변환
1). 6.25를 2진수로 변환
(위에서 한 것과 동일)

(6.25)₁₀ = (110.01)₂
2). 정규화 (소수점 이동)
부동 소수점은 1.xxxxxx × 2^n 형태로 변환해야 해.

110.01₂ = 1.1001 × 2²
소수점을 1.1001 뒤로 이동했으므로 지수는 2.

#### IEEE 754 형식에 맞게 변환
|필드	|값	|설명|
|-|-|-|
|부호 (1비트)	|0|6.25는 양수
|지수 (8비트)	|2 + 127 = 129 → 10000001|	Bias 127 적용
|가수 (23비트)	|10010000000000000000000|	소수점 뒤 숫자

최종 IEEE 754 단정도(32비트) 표현

0 10000001 10010000000000000000000
16진수 표현: 0x40C80000

## 패리티 비트 & 해밍 코드
### 패리티 비트
정보 전달 과정에서 오류가 생겼는 지 검사하기 위해 추가하는 비트를 말한다.
전송하고자 하는 데이터의 각 문자에 1비트를 더하여 전송한다.

종류 : 짝수, 홀수
전체 비트에서 (짝수, 홀수)에 맞도록 비트를 정하는 것

짝수 패리티일 때 7비트 데이터가 1010001라면?
1이 총 3개이므로, 짝수로 맞춰주기 위해 1을 더해야 함

답 : 11010001 (맨앞이 패리티비트)



### 해밍 코드
데이터 전송 시 1비트의 에러를 정정할 수 있는 자기 오류정정 코드를 말한다.

패리티비트를 보고, 1비트에 대한 오류를 정정할 곳을 찾아 수정할 수 있다. (패리티 비트는 오류를 검출하기만 할 뿐 수정하지는 않기 때문에 해밍 코드를 활용)

#### 방법
2의 n승 번째 자리인 1,2,4번째 자릿수가 패리티 비트라는 것으로 부터 시작한다. 이 숫자로부터 시작하는 세개의 패리티 비트가 짝수인지, 홀수인지 기준으로 판별한다.


짝수 패리티의 해밍 코드가 0011011일때 오류가 수정된 코드는?

1, 3, 5, 7번째 비트 확인 : 0101로 짝수이므로 '0'

2, 3, 6, 7번째 비트 확인 : 0111로 홀수이므로 '1'

4, 5, 6, 7번째 비트 확인 : 1011로 홀수이므로 '1'


역순으로 패리티비트 '110'을 도출했다. 10진법으로 바꾸면 '6'으로, 6번째 비트를 수정하면 된다.

따라서 정답은 00110'0'1이다.







